using System;
using System.Collections.Generic;
using System.Text;

namespace PostgREST.DbContext.Provider.Analyzers.Schema;

/// <summary>
/// Generates C# entity source code from a list of <see cref="TableDefinition"/> objects
/// obtained from the PostgREST OpenAPI schema.
/// </summary>
internal static class EntityCodeGenerator
{
    /// <summary>
    /// Returns the PascalCase class name that will be generated for a table.
    /// </summary>
    public static string GetClassName(TableDefinition table)
        => ToPascalCase(table.Name);

    /// <summary>
    /// Returns a complete C# source file containing a single entity class
    /// for the given <paramref name="table"/>.
    /// </summary>
    public static string GenerateSingle(TableDefinition table, string rootNamespace)
    {
        var sb = new StringBuilder();
        bool hasCompositeKey = HasCompositePrimaryKey(table);
        AppendFileHeader(sb, rootNamespace, hasCompositeKey);
        GenerateEntity(sb, table);
        return sb.ToString();
    }

    /// <summary>
    /// Returns a complete C# source file with entity classes for every table.
    /// </summary>
    public static string Generate(List<TableDefinition> tables, string rootNamespace)
    {
        var sb = new StringBuilder();
        bool anyCompositeKey = false;
        for (var i = 0; i < tables.Count; i++)
        {
            if (HasCompositePrimaryKey(tables[i]))
            {
                anyCompositeKey = true;
                break;
            }
        }

        AppendFileHeader(sb, rootNamespace, anyCompositeKey);

        for (var i = 0; i < tables.Count; i++)
        {
            GenerateEntity(sb, tables[i]);

            if (i < tables.Count - 1)
                sb.AppendLine();
        }

        return sb.ToString();
    }

    // ─────────────────────────────────────────────────────────────────────

    private static void AppendFileHeader(StringBuilder sb, string rootNamespace, bool includeEfCoreUsing)
    {
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("//   Generated by PostgREST Schema Designer.");
        sb.AppendLine("//   Re-run the code fix to regenerate after schema changes.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.ComponentModel.DataAnnotations;");
        sb.AppendLine("using System.ComponentModel.DataAnnotations.Schema;");
        if (includeEfCoreUsing)
            sb.AppendLine("using Microsoft.EntityFrameworkCore;");
        sb.AppendLine();
        sb.AppendLine($"namespace {rootNamespace}.Models;");
        sb.AppendLine();
    }

    private static bool HasCompositePrimaryKey(TableDefinition table)
    {
        int pkCount = 0;
        for (var i = 0; i < table.Columns.Count; i++)
        {
            if (table.Columns[i].IsPrimaryKey)
                pkCount++;
            if (pkCount > 1)
                return true;
        }
        return false;
    }

    private static void GenerateEntity(StringBuilder sb, TableDefinition table)
    {
        var className = ToPascalCase(table.Name);
        bool compositeKey = HasCompositePrimaryKey(table);

        sb.AppendLine($"[Table(\"{table.Name}\")]");

        if (compositeKey)
        {
            var pkParts = new List<string>();
            for (var i = 0; i < table.Columns.Count; i++)
            {
                if (table.Columns[i].IsPrimaryKey)
                    pkParts.Add($"nameof({ToPascalCase(table.Columns[i].Name)})");
            }
            sb.AppendLine($"[PrimaryKey({string.Join(", ", pkParts)})]");
        }

        sb.AppendLine($"public class {className}");
        sb.AppendLine("{");

        for (var j = 0; j < table.Columns.Count; j++)
        {
            var col = table.Columns[j];
            GenerateProperty(sb, col, table.RequiredColumns.Contains(col.Name), compositeKey);

            if (j < table.Columns.Count - 1)
                sb.AppendLine();
        }

        sb.AppendLine("}");
    }

    private static void GenerateProperty(
        StringBuilder sb,
        ColumnDefinition col,
        bool isRequired,
        bool isCompositeKey)
    {
        var propertyName = ToPascalCase(col.Name);
        var csharpType   = MapToCSharpType(col.JsonType, col.Format);
        var isValueType  = IsValueType(csharpType);
        var isNullable   = !isRequired && !col.IsPrimaryKey;

        if (col.IsArray)
            csharpType = $"List<{csharpType}>";

        // ── Data-annotation attributes ──────────────────────────────────

        if (col.IsPrimaryKey && !isCompositeKey)
            sb.AppendLine("    [Key]");

        if (col.IsPrimaryKey && col.Default != null)
            sb.AppendLine("    [DatabaseGenerated(DatabaseGeneratedOption.Identity)]");

        if (isRequired && !col.IsPrimaryKey && !isValueType)
            sb.AppendLine("    [Required]");

        if (col.MaxLength.HasValue)
            sb.AppendLine($"    [MaxLength({col.MaxLength.Value})]");

        if (col.Name != propertyName)
            sb.AppendLine($"    [Column(\"{col.Name}\")]");

        // ── Property declaration ────────────────────────────────────────

        var typeStr = isNullable ? csharpType + "?" : csharpType;

        var initializer = string.Empty;
        if (!isNullable && !isValueType && !col.IsArray)
            initializer = " = default!;";
        else if (!isNullable && col.IsArray)
            initializer = " = [];";

        sb.AppendLine($"    public {typeStr} {propertyName} {{ get; set; }}{initializer}");
    }

    // ── Type mapping ────────────────────────────────────────────────────

    /// <summary>
    /// Maps a JSON Schema type + PostgREST format to a C# type name.
    /// PostgREST uses PostgreSQL type names in the <c>format</c> field.
    /// </summary>
    private static string MapToCSharpType(string jsonType, string? format)
    {
        var jt  = (jsonType  ?? "string").ToLowerInvariant();
        var fmt = format?.ToLowerInvariant();

        // ── integers ────────────────────────────────────────────────────
        if (jt == "integer")
        {
            if (fmt == "bigint" || fmt == "int8")
                return "long";
            if (fmt == "smallint" || fmt == "int2")
                return "short";
            return "int";
        }

        // ── numbers ─────────────────────────────────────────────────────
        if (jt == "number")
        {
            if (fmt == "real" || fmt == "float4" || fmt == "float")
                return "float";
            if (fmt == "numeric" || fmt == "decimal" || fmt == "money")
                return "decimal";
            return "double";
        }

        // ── booleans ────────────────────────────────────────────────────
        if (jt == "boolean")
            return "bool";

        // ── strings with format hints ───────────────────────────────────
        if (jt == "string" && fmt != null)
        {
            if (fmt == "uuid")
                return "Guid";
            if (fmt == "date")
                return "DateOnly";
            if (fmt == "time without time zone" || fmt == "time")
                return "TimeOnly";
            if (fmt == "timestamp without time zone" || fmt == "timestamp")
                return "DateTime";
            if (fmt == "timestamp with time zone" || fmt == "timestamptz")
                return "DateTimeOffset";
            if (fmt == "interval")
                return "TimeSpan";
            if (fmt == "bytea")
                return "byte[]";
        }

        return "string";
    }

    private static bool IsValueType(string csharpType)
    {
        switch (csharpType)
        {
            case "int":
            case "long":
            case "short":
            case "float":
            case "double":
            case "decimal":
            case "bool":
            case "Guid":
            case "DateOnly":
            case "TimeOnly":
            case "DateTime":
            case "DateTimeOffset":
            case "TimeSpan":
                return true;
            default:
                return false;
        }
    }

    // ── Naming helpers ──────────────────────────────────────────────────

    /// <summary>
    /// Converts <c>snake_case</c> to <c>PascalCase</c>.
    /// </summary>
    private static string ToPascalCase(string snakeCase)
    {
        if (string.IsNullOrEmpty(snakeCase))
            return snakeCase;

        var sb = new StringBuilder(snakeCase.Length);
        var capitalizeNext = true;

        foreach (var ch in snakeCase)
        {
            if (ch == '_')
            {
                capitalizeNext = true;
                continue;
            }

            sb.Append(capitalizeNext ? char.ToUpperInvariant(ch) : ch);
            capitalizeNext = false;
        }

        // C# identifiers cannot start with a digit.
        if (sb.Length > 0 && char.IsDigit(sb[0]))
            sb.Insert(0, '_');

        return sb.ToString();
    }
}
